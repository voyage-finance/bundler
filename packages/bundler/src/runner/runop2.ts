// runner script, to create

/**
 * a simple script runner, to test the bundler and API.
 * for a simple target method, we just call the "nonce" method of the account itself.
 */

import { BigNumber, getDefaultProvider, Signer, Wallet } from 'ethers'
import { JsonRpcProvider } from '@ethersproject/providers'
import { SimpleAccountDeployer__factory } from '@account-abstraction/contracts'
import { formatEther, keccak256, parseEther } from 'ethers/lib/utils'
import { Command } from 'commander'
import { erc4337RuntimeVersion } from '@account-abstraction/utils'
import fs from 'fs'
import { DeterministicDeployer, HttpRpcClient, SimpleAccountAPI } from '@account-abstraction/sdk'
import { BundlerServer } from '../BundlerServer'
import {
  EIP4337Manager,
  EIP4337Manager__factory,
  EntryPoint__factory,
  GnosisSafe__factory,
  SafeProxy4337,
  SafeProxy4337__factory,
  TestCounter__factory
} from '../typechain'
import { fillAndSign } from './UserOp'
import { SingleEntryPlugin } from 'webpack'
import { SimpleAccount__factory } from '../types'


const ENTRY_POINT = '0x5a6c313240e2a8a868487a2e7010ce3880d04f56'

class Runner {
  bundlerProvider!: HttpRpcClient
  accountApi!: SimpleAccountAPI

  /**
   *
   * @param provider - a provider for initialization. This account is used to fund the created account contract, but it is not the account or its owner.
   * @param bundlerUrl - a URL to a running bundler. must point to the same network the provider is.
   * @param accountOwner - the wallet signer account. used only as signer (not as transaction sender)
   * @param entryPointAddress - the entrypoint address to use.
   * @param index - unique salt, to allow multiple accounts with the same owner
   */
  constructor (
    readonly provider: JsonRpcProvider,
    readonly bundlerUrl: string,
    readonly accountOwner: Signer,
    readonly entryPointAddress = ENTRY_POINT,
    readonly index = 0
  ) {
  }

  async getAddress (): Promise<string> {
    return await this.accountApi.getCounterFactualAddress()
  }

  async init (deploymentSigner?: Signer): Promise<this> {
    const net = await this.provider.getNetwork()
    const chainId = net.chainId
    const dep = new DeterministicDeployer(this.provider)
    const accountDeployer = await dep.getDeterministicDeployAddress(SimpleAccountDeployer__factory.bytecode)
    // const accountDeployer = await new SimpleAccountDeployer__factory(this.provider.getSigner()).deploy().then(d=>d.address)
    if (!await dep.isContractDeployed(accountDeployer)) {
      if (deploymentSigner == null) {
        process.exit(1)
      }
      console.log('deploymentSigner.provider: ', deploymentSigner.provider)
      const dep1 = new DeterministicDeployer(deploymentSigner.provider as any)
      await dep1.deterministicDeploy(SimpleAccountDeployer__factory.bytecode)
    }
    this.bundlerProvider = new HttpRpcClient(this.bundlerUrl, this.entryPointAddress, chainId)
    this.accountApi = new SimpleAccountAPI({
      provider: this.provider,
      entryPointAddress: this.entryPointAddress,
      factoryAddress: accountDeployer,
      owner: this.accountOwner,
      index: this.index,
      overheads: {
        // perUserOp: 100000
      }
    })
    return this
  }

  parseExpectedGas (e: Error): Error {
    // parse a custom error generated by the BundlerHelper, which gives a hint of how much payment is missing
    const match = e.message?.match(/paid (\d+) expected (\d+)/)
    if (match != null) {
      const paid = Math.floor(parseInt(match[1]) / 1e9)
      const expected = Math.floor(parseInt(match[2]) / 1e9)
      return new Error(`Error: Paid ${paid}, expected ${expected} . Paid ${Math.floor(paid / expected * 100)}%, missing ${expected - paid} `)
    }
    return e
  }

  async runUserOp (target: string, data: string): Promise<void> {
    const userOp = await this.accountApi.createSignedUserOp({
      target,
      data,
      gasLimit: 1000000000,
      maxFeePerGas: 200000000000,
      maxPriorityFeePerGas: 200000000000
    })
    console.log('userOp: ', userOp)
    try {
      const userOpHash = await this.bundlerProvider.sendUserOpToBundler(userOp)
      const txid = await this.accountApi.getUserOpReceipt(userOpHash)
      console.log('reqId', userOpHash, 'txid=', txid)
    } catch (e: any) {
      throw this.parseExpectedGas(e)
    }
  }
}

async function main (): Promise<void> {
  const program = new Command()
    .version(erc4337RuntimeVersion)
    .option('--network <string>', 'network name or url', 'http://localhost:8545')
    .option('--mnemonic <file>', 'mnemonic/private-key file of signer account (to fund account)')
    .option('--bundlerUrl <url>', 'bundler URL', 'http://localhost:3000/rpc')
    .option('--entryPoint <string>', 'address of the supported EntryPoint contract', ENTRY_POINT)
    .option('--deployDeployer', 'Deploy the "account deployer" on this network (default for testnet)')
    .option('--show-stack-traces', 'Show stack traces.')
    .option('--selfBundler', 'run bundler in-process (for debugging the bundler)')

  console.log('opts')
  const opts = program.parse().opts()
  const provider = getDefaultProvider(opts.network) as JsonRpcProvider
  let signer: Signer
  const deployDeployer: boolean = opts.deployDeployer
  let bundler: BundlerServer | undefined
  if (opts.mnemonic != null) {
    signer = Wallet.fromMnemonic(fs.readFileSync(opts.mnemonic, 'ascii').trim()).connect(provider)
  } else {
    try {
      const accounts = await provider.listAccounts()
      if (accounts.length === 0) {
        console.log('fatal: no account. use --mnemonic (needed to fund account)')
        process.exit(1)
      }
      // for hardhat/node, use account[0]
      signer = provider.getSigner()
      // deployDeployer = true
    } catch (e) {
      throw new Error('must specify --mnemonic')
    }
  }
  const accountOwner = Wallet.fromMnemonic(fs.readFileSync(opts.mnemonic, 'ascii').trim()).connect(provider)
  console.log('account owner: ', accountOwner.address)

  const index = 0
  // const client = await new Runner(provider, opts.bundlerUrl, accountOwner, opts.entryPoint, index).init(deployDeployer ? signer : undefined)

  // const addr = await client.getAddress()
  // console.log('addr: ', addr)
  const gnosisSafeAddr = '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512'
  const entryPointAddr = '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0'
  const managerAddr = '0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9'
  const counterAddr = '0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9'
  const safeProxyAddr = '0x5FC8d32690cc91D4c39d9d3abcBD16989F875707'
  const addr = '0x0165878A594ca255338adfa4d48449f69242Eb8F'

  async function isDeployed (addr: string): Promise<boolean> {
    return await provider.getCode(addr).then(code => code !== '0x')
  }

  async function getBalance (addr: string): Promise<BigNumber> {
    return await provider.getBalance(addr)
  }
  

  const bal = await getBalance(addr)
  console.log('account address', addr, 'deployed=', await isDeployed(addr), 'bal=', formatEther(bal))
  //TODO: actual required val
  const requiredBalance = parseEther('10')
  if (bal.lt(requiredBalance.div(2))) {
    console.log('funding account to', requiredBalance)
    await signer.sendTransaction({
      to: addr,
      gasLimit: '10000000',
      gasPrice: '200000000000',
      value: requiredBalance.sub(bal)
    })
  } else {
    console.log('not funding account. balance is enough')
  }


  const safeSingleton = await new GnosisSafe__factory(accountOwner).attach(gnosisSafeAddr).connect(provider)
  const counter = await new TestCounter__factory(accountOwner).attach(counterAddr).connect(provider)
  const simpleAccount = await new SimpleAccount__factory().attach(addr);
  const counter_countCallData = counter.interface.encodeFunctionData('count')
  const simpleAccountCallData = simpleAccount.interface.encodeFunctionData('execFromEntryPoint',[counterAddr,0,counter_countCallData])
  const safe_execTxCallData = safeSingleton.interface.encodeFunctionData('execTransactionFromModule', [counter.address, 0, counter_countCallData, 0])
  console.log("safe_execTxCallData: ", safe_execTxCallData)

  const proxy = await new SafeProxy4337__factory(accountOwner).attach(safeProxyAddr)
  const entryPoint = await new EntryPoint__factory(accountOwner).attach(entryPointAddr)
  const manager = await new EIP4337Manager__factory().attach(managerAddr).connect(accountOwner)
  // console.log('start validateEip4337')
  // await manager.callStatic.validateEip4337(gnosisSafeAddr, manager.address, { gasLimit: 10e6 })
  // console.log('end validateEip4337')
  const op = await fillAndSign({
    sender: safeProxyAddr,
    callGasLimit: 1e6,
    callData: safe_execTxCallData
  }, accountOwner, entryPoint)
  const rcpt = await entryPoint.handleOps([op], accountOwner.address).then(async r => r.wait());
  console.log('gasUsed=', rcpt.gasUsed, rcpt.transactionHash)
  const ev = rcpt.events!.find(ev => ev.event === 'UserOperationEvent')!
  console.log(ev)
}

void main()
